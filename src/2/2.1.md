# ä¸ºä»€ä¹ˆè¦ç”¨TypeScriptï¼Ÿ

æ­£å¸¸æ¥è®²ï¼Œåªä¼šESMå†™æ³•ä¹Ÿæ˜¯è¶³å¤Ÿå¼€å‘Node.jsç”¨çš„ï¼ŒæŒæ¡äº†TypeScriptå¯ä»¥æ›´å¥½çš„åº”å¯¹å¤§è§„æ¨¡åº”ç”¨å¼€å‘ï¼Œå¤šèŠ±ä¸€ç‚¹æ—¶é—´ï¼Œå¯¹å¯ç»´æŠ¤æ€§æ›´å¥½ã€‚

- è‰¯å¥½çš„ç±»å‹æ”¯æŒæ˜¯ç°ä»£æ¡†æ¶å¿…é¡»çš„åŠŸèƒ½
- å¯ç»´æŠ¤æ€§å¤§å¤§æå‡ï¼Œä¸ºè¿­ä»£æ‰“ä¸‹åšå®åŸºç¡€
- é€‚ç”¨äºå¤§è§„æ¨¡å¼€å‘

![Untitled](img/Untitled%203.png)

## é»‘ç²‰

![Untitled](img/Untitled%204.png)

Ruby on Railsä½œè€…DHHåœ¨2023å¹´å®£å¸ƒåœ¨Turbo 8ä¸­æ”¾å¼ƒä½¿ç”¨TypeScriptï¼Œç¬”è€…ä»¥ä¸ºRailsæœ¬èº«è¿½æ±‚çš„æ˜¯å¼€å‘æ•ˆç‡ï¼Œåäº”åˆ†é’Ÿå†™ä¸€ä¸ªBlogï¼Œç»“æœåŠ äº†TypeScriptï¼Œäº”åˆ†é’Ÿè¿˜æ²¡å†™å®Œç±»å‹å®šä¹‰ã€‚æ•æ·ç¤¾åŒºå–œæ¬¢æµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTDDï¼‰ï¼Œæœ¬æ¥åªéœ€è¦æ”¹æ”¹ä»£ç å°±è¡Œï¼Œç°åœ¨è¿˜è¦ç®¡ç±»å‹å®šä¹‰å’Œç±»å‹ æµ‹è¯•ï¼Œå¾ˆæ˜¾ç„¶ï¼Œè¿™æ ·åšçš„æ•ˆç‡å’Œè´¨é‡æ˜¯çŸ›ç›¾çš„ï¼Œåœ¨æ”¶ç›Šä¸å¤Ÿé«˜çš„æ—¶å€™ï¼Œæ”¾å¼ƒä¹Ÿæ˜¯æ­£å¸¸ã€‚ç±»å‹å’Œæµ‹è¯•éƒ½æ˜¯ä¸€ä¸ª[ä¸Šä¸‹æ–‡](https://link.zhihu.com/?target=https%3A//www.jdon.com/tag-15977/)çš„ä¸Šæ–‡ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªä¸Šä¸‹æ–‡çš„é¢„è®¾ï¼Œå¦‚æœé¢„è®¾ç±»å‹é”™è¯¯äº†ï¼Œå…¨ç›˜çš†è¾“ï¼Œæ— ç±»å‹çš„Javascriptåˆ™åœ¨æ¢ç´¢ä¸ç¡®å®šé—®é¢˜ä¸Šæ•ˆç‡æ›´é«˜ã€‚


1ã€Railsæ˜¯å´‡å°šæ•ˆç‡çš„æ¡†æ¶ï¼Œæˆªå›¾ä¸­5åˆ†é’Ÿé‚£ä¸ªæœ‰è¯¯ï¼Œæ—©åœ¨2005å¹´[dhh](https://www.zhihu.com/search?q=dhh&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3222336155%7D)æˆåä¹‹ä½œï¼Œå°±æ˜¯15åˆ†é’Ÿå†™ä¸€ä¸ªBlogã€‚æ‰€ä»¥åŠ äº†tsï¼Œä¼šé˜»ç¢æ•ˆç‡ï¼Œå¯¹äºè¿™æ ·ä¸€ä¸ªè¿½æ±‚æè‡´æ•ˆç‡çš„å›¢é˜Ÿï¼Œå¼ƒç”¨æ˜¯æ­£å¸¸çš„ã€‚

2ã€TSé€‚åˆçš„æ˜¯å¤§å‹é¡¹ç›®ï¼Œå›¢é˜Ÿæ°´å¹³è¦ä¹ˆå¾ˆé«˜ï¼Œè¦ä¹ˆå¾ˆä½ï¼Œå…¶å®æ•ˆæœéƒ½æ˜¯éå¸¸å¥½çš„ã€‚è€ŒRailså…¶å®ä¸æ˜¯å¾ˆå¤§å‹çš„é¡¹ç›®ï¼Œæˆ‘æ²¡å¤ªè§è¿‡ï¼Œå¤§å®¶éƒ½æ˜¯æƒ³å¿«é€Ÿäº¤ä»˜ã€‚

3ã€Rubyç¤¾åŒºæœ‰[æ•æ·åŸºå› ](https://www.zhihu.com/search?q=%E6%95%8F%E6%8D%B7%E5%9F%BA%E5%9B%A0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3222336155%7D)ï¼Œå–œæ¬¢TDDæˆ–XPï¼Œä»£ç å˜åŠ¨æå¿«çš„æƒ…å†µä¸‹ï¼Œè¦æŠŠæµ‹è¯•æ”¹å®Œï¼Œè¦å…³æ³¨ç±»å‹æµ‹è¯•ï¼Œå°±ä¼šå¤šå‡ºéå¸¸å¤šçš„å·¥ä½œã€‚

4ã€Railsç¨‹åºå‘˜ä¹Ÿéƒ½æ˜¯ä»¥Rubyä¸ºä¸»ï¼Œjsä¸ºè¾…ã€‚å½“jsèƒ½å®Œæˆï¼Œéè¦ç”¨tsæï¼Œä¼šå¸¦æ¥å¾ˆå¤šè´Ÿæ‹…ï¼Œå¯¹ä»–ä»¬è€Œè¨€roiä¸é«˜ã€‚å‰ç«¯ä¹‹æ‰€ä»¥å–œæ¬¢tsï¼Œå‰ç«¯ä¼šjsä¸ºä¸»ï¼Œä»¥tsä¸ºè¾…å°±å¾ˆç®€å•ã€‚

æŸäº›åœºæ™¯ç¡®å®ä¸éœ€è¦TSï¼Œçº¯ESå·²ç»æ¯”jså¥½å¾ˆå¤šäº†ï¼Œè¿™ç§çº¯ç”¨ES/JSçš„æ¯”ä¾‹æ˜¯æ¯”è¾ƒå°‘çš„ã€‚

## å¥‰è‹¥ç¥æ•™

ä¸»è¦äººç¾¤ï¼šå¤§å‚å‰ç«¯ã€å¼€æºè´¡çŒ®è€…ã€‚

TSé€‚åˆçš„æ˜¯å¤§å‹é¡¹ç›®ï¼Œå›¢é˜Ÿæ°´å¹³è¦ä¹ˆå¾ˆé«˜ï¼Œè¦ä¹ˆå¾ˆä½ã€‚

![Untitled](img/Untitled%205.png)

é«˜pä¼šæƒ³ï¼Œä¸‹é¢çš„ä¸€çº¿åŒå­¦å°‘çŠ¯ç‚¹ä½çº§é”™è¯¯ï¼Œå‚è€ƒç°åœ¨è¿™æ•…éšœåˆ†ï¼Œæå¾—äººå¿ƒæƒ¶æƒ¶ï¼Œå¦‚æœåªæ˜¯éº»çƒ¦ä¸€ä¸‹ä¸€çº¿å¼€å‘ï¼Œå¯¹ç¨³å®šæ€§æœ‰å¥½å¤„ï¼Œé—®é¢˜ä¸å¤§ã€‚ä¸€çº¿åŒå­¦ï¼Œå¤§å®¶éƒ½è§‰å¾—tsæŒºå…ˆè¿›ï¼Œåˆ«ç®¡ä¼šä¸ä¼šï¼Œç”¨ä¸Šå†è¯´ï¼Œä¸è¡Œè¿˜æœ‰anyå¤§æ³•ã€‚é€šå¸¸å¤§å‚éƒ½æ˜¯ä¼šæ¯”è¾ƒæ„¿æ„ç”¨tsçš„ã€‚

- è§„èŒƒï¼Œæ¯”é»‘é­”æ³•è¦é‡è¦ï¼Œè¿™å…¶å®ä¹Ÿæ˜¯é€‰Reactçš„åŸå› ã€‚
- ä½çº§é”™è¯¯å°‘ï¼Œäººæ°´å¹³å¦‚æœé«˜ï¼Œå…¶å®ä¹Ÿæ— æ‰€è°“çš„ï¼Œå°±æ€•å‚å·®ä¸é½ã€‚
- ä¸å·®é‚£ç‚¹æ—¶é—´ï¼Œddddã€‚
- ä¸å‡ºæ•…éšœå•¥éƒ½å¥½ï¼Œç¨³å®šæ€§å‹åˆ°ä¸€åˆ‡ã€‚
- ä¼ æ‰¿ä¼šå¥½çš„å¤šï¼Œå–œæ¬¢ç ”ç©¶å¸¦ç€é£ã€‚

## ä¸­ç«‹

![Untitled](img/Untitled%206.png)

ä¸å¹ä¸é»‘ã€‚

<aside>
ğŸ’¡ ä»”ç»†æƒ³äº†ä¸€ä¸‹ï¼Œæˆ‘åº”è¯¥æ˜¯ä¸­ç«‹æ´¾ã€‚ä»Commonjsæ—¶ä»£è¿‡æ¥ï¼Œæˆ‘ä¹ æƒ¯jsï¼Œåœ¨å¤§å‚å¤šå¹´ï¼Œä¹Ÿä¹ æƒ¯äº†tså„ç§å¥‡æŠ€æ·«å·§ã€‚æˆ‘çš„è§‚ç‚¹æ˜¯å†™åº“è¦ä¸¥æ ¼ç”¨tsï¼Œå†™åº”ç”¨ï¼Œå¯ä»¥æ”¾å®½ï¼Œåä½œäººè¶Šå¤šï¼Œè¶Šåº”è¯¥å°‘ç”¨Hackã€‚
</aside>

æˆ‘çš„è§‚ç‚¹ï¼šå¯¹äºTSï¼Œä½ ä¸€å®šè¦å­¦ï¼Œä½†åœ¨ä¸åœ¨é¡¹ç›®ä½¿ç”¨ä¾ç…§å›¢é˜Ÿå’Œé¡¹ç›®ç±»å‹è€Œå®šã€‚

## ä¸¾ä¾‹çœ‹ä¸€ä¸‹tsæˆæœ¬

ä»¥tomcatä¸ºä¾‹ã€‚

```jsx
import debug from 'debug';
import Koa from 'koa';

import { Plugable } from './plugin';
import { mergeDeep } from './utils';

const log = debug('@tomrpc/core/fn');

const ProxyDefaultConfig = {
  proxy: {
    inject: 'before', //init | load | before | after
    before: [],
  },
};

export interface IProxyConfig {
  name?: string | 'tomapp';
  proxy?: {
    inject: 'init' | 'load' | 'before' | 'after';
    before: [];
  };
}

export class Proxy extends Plugable {
  public inject;

  constructor(cfg?: IProxyConfig) {
    super(mergeDeep(ProxyDefaultConfig, cfg));
  }

  proxy() {
    return async (ctx: Koa.BaseContext, next) => {
      log('proxy default');
      await next();
      log('proxy default end');
    };
  }
}
```

æœ€åˆçš„ç‰ˆæœ¬ï¼Œæˆ‘åŸºæœ¬ä¸ŠåªåŠ äº†å¿…è¦çš„ç±»å‹ã€‚æ¯”å¦‚é…ç½®é¡¹è¿™ç§ã€‚

ä»¥honoä¸ºä¾‹ã€‚

```jsx
import { HonoBase } from './hono-base'
import type { HonoOptions } from './hono-base'
import { RegExpRouter } from './router/reg-exp-router'
import { SmartRouter } from './router/smart-router'
import { TrieRouter } from './router/trie-router'
import type { Env, Schema } from './types'

export class Hono<
  E extends Env = Env,
  S extends Schema = {},
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    this.router =
      options.router ??
      new SmartRouter({
        routers: [new RegExpRouter(), new TrieRouter()],
      })
  }
}

export type MiddlewareHandler<
  E extends Env = any,
  P extends string = string,
  I extends Input = {}
> = (c: Context<E, P, I>, next: Next) => Promise<Response | void>
```

å¦å¤–ï¼Œrouterä¹Ÿæ˜¯ä¸ªå¥½ä¾‹å­

```jsx
/* eslint-disable @typescript-eslint/ban-ts-comment */
import type { Router, Result } from '../../router'
import { UnsupportedPathError, MESSAGE_MATCHER_IS_ALREADY_BUILT } from '../../router'

export class SmartRouter<T> implements Router<T> {
  name: string = 'SmartRouter'
  routers: Router<T>[] = []
  routes?: [string, string, T][] = []

  constructor(init: Pick<SmartRouter<T>, 'routers'>) {
    Object.assign(this, init)
  }

  add(method: string, path: string, handler: T) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT)
    }

    this.routes.push([method, path, handler])
  }

  match(method: string, path: string): Result<T> {
    if (!this.routes) {
      throw new Error('Fatal error')
    }

    const { routers, routes } = this
    const len = routers.length
    let i = 0
    let res
    for (; i < len; i++) {
      const router = routers[i]
      try {
        routes.forEach((args) => {
          router.add(...args)
        })
        res = router.match(method, path)
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue
        }
        throw e
      }

      this.match = router.match.bind(router)
      this.routers = [router]
      this.routes = undefined
      break
    }

    if (i === len) {
      // not found
      throw new Error('Fatal error')
    }

    // e.g. "SmartRouter + RegExpRouter"
    this.name = `SmartRouter + ${this.activeRouter.name}`

    return res as Result<T>
  }

  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error('No active router has been determined yet.')
    }

    return this.routers[0]
  }
}
```

ç®€å•ï¼Œè§„çŸ©ã€‚

trpc
